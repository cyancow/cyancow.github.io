



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://docs.prometheus.cool/network/flannel/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../assets/img/prometheus_logo.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.0.2">
    
    
      
        <title>Flannel - 云原生监控神器Prometheus</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.982221ab.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#ef5350">
      
    
    
      <script src="../../assets/javascripts/modernizr.1f0bcf2b.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../assets/styles/extra.css">
    
      <link rel="stylesheet" href="../../assets/styles/prism.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="red" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#flannel" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://docs.prometheus.cool" title="云原生监控神器Prometheus" class="md-header-nav__button md-logo">
          
            <img src="../../assets/img/prometheus_logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              云原生监控神器Prometheus
            </span>
            <span class="md-header-nav__topic">
              Flannel
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/k8stech/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://docs.prometheus.cool" title="云原生监控神器Prometheus" class="md-nav__button md-logo">
      
        <img src="../../assets/img/prometheus_logo.png" width="48" height="48">
      
    </a>
    云原生监控神器Prometheus
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/k8stech/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="介绍" class="md-nav__link">
      介绍
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      监控基础与概述
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        监控基础与概述
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../monitorbasic/whymonitor/" title="为什么要监控" class="md-nav__link">
      为什么要监控
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../monitorbasic/monitorterms/" title="监控术语" class="md-nav__link">
      监控术语
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../monitorbasic/metricstory/" title="指标物语" class="md-nav__link">
      指标物语
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../monitorbasic/monitorcontrast/" title="开源监控对比" class="md-nav__link">
      开源监控对比
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Prometheus 基础
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Prometheus 基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../basic/prom-introduction/" title="Prometheus介绍" class="md-nav__link">
      Prometheus介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../basic/tsdb-contrast/" title="时序数据库对比" class="md-nav__link">
      时序数据库对比
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../basic/prom-datamodel/" title="数据模型" class="md-nav__link">
      数据模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../basic/node-exporter/" title="Node_Exporter" class="md-nav__link">
      Node_Exporter
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../basic/prom-config/" title="Prometheus安装与配置" class="md-nav__link">
      Prometheus安装与配置
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Prometheus 进阶
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Prometheus 进阶
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../advanced/auto-ops-exporter-1/" title="自动化维护Exporter（一）" class="md-nav__link">
      自动化维护Exporter（一）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../advanced/auto-ops-exporter-2/" title="自动化维护Exporter（二）" class="md-nav__link">
      自动化维护Exporter（二）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../advanced/docker-swarm-monitor-1/" title="Docker-Swarm集群监控（一）" class="md-nav__link">
      Docker-Swarm集群监控（一）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../advanced/docker-swarm-monitor-2/" title="Docker-Swarm集群监控（二）" class="md-nav__link">
      Docker-Swarm集群监控（二）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../advanced/commonly-exporter/" title="常用Exporter介绍与配置" class="md-nav__link">
      常用Exporter介绍与配置
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Prometheus(警报)
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Prometheus(警报)
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/promql-basic/" title="PromQL详解（一）" class="md-nav__link">
      PromQL详解（一）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/promql-operator/" title="PromQL详解（二）" class="md-nav__link">
      PromQL详解（二）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/promql-operator2/" title="PromQL详解（三）" class="md-nav__link">
      PromQL详解（三）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/promql-function/" title="PromQL函数" class="md-nav__link">
      PromQL函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/alertmanager-overview/" title="AlertManager" class="md-nav__link">
      AlertManager
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/alertmanager-rules-1/" title="Rules详解（一）" class="md-nav__link">
      Rules详解（一）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/alertmanager-rules-2/" title="Rules详解（二）" class="md-nav__link">
      Rules详解（二）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/alertmanager-receiver/" title="Receiver配置" class="md-nav__link">
      Receiver配置
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Alertmanager/alertmanager-silences/" title="Silences配置" class="md-nav__link">
      Silences配置
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Prometheus(联邦集群)
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        Prometheus(联邦集群)
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../federation/federation-overview/" title="Prometheus 联邦集群" class="md-nav__link">
      Prometheus 联邦集群
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../federation/pushgateway/" title="Pushgateway 代理" class="md-nav__link">
      Pushgateway 代理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../federation/alertmanager-ha/" title="Alertmanager 高可用" class="md-nav__link">
      Alertmanager 高可用
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      Prometheus(服务发现)
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        Prometheus(服务发现)
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../discover-service/discovery-overview/" title="服务发现（文件、DNS）" class="md-nav__link">
      服务发现（文件、DNS）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../discover-service/discovery-relabeling/" title="服务发现（Relabelling）" class="md-nav__link">
      服务发现（Relabelling）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../discover-service/discovery-consul/" title="服务发现（Consul）" class="md-nav__link">
      服务发现（Consul）
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      Prometheus(Operator)
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        Prometheus(Operator)
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Kubernetes/Prometheus-Operator/" title="Operator概述" class="md-nav__link">
      Operator概述
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Kubernetes/Prometheus-Statefulsets-1/" title="手动部署（1）" class="md-nav__link">
      手动部署（1）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Kubernetes/Prometheus-Statefulsets-2/" title="手动部署（2）" class="md-nav__link">
      手动部署（2）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Kubernetes/Prometheus-Statefulsets-3/" title="手动部署（联邦）" class="md-nav__link">
      手动部署（联邦）
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#udp" title="UDP 方式" class="md-nav__link">
    UDP 方式
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vxlan" title="VXLAN 方式" class="md-nav__link">
    VXLAN 方式
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#host-gw" title="host-gw" class="md-nav__link">
    host-gw
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/k8stech/edit/master/docs/network/flannel.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="flannel">Flannel<a class="headerlink" href="#flannel" title="Permanent link">&para;</a></h1>
<p>我们知道 Docker 的网络模式可以解决一个节点上的容器之间的网络通信问题，但是对于跨主机的容器之间的通信就无能为力了，就需要借助第三方的工具来实现容器的跨主机通信。为解决容器跨主机通信问题，社区出现了很多种网络解决方案，不同的方案工作原理各有不同，对于网络环境的要求也各有不同，我们这里以使用最多的 <code>Flannel</code> 这个网络插件为例，来给大家讲解该经典网络插件的工作原理。</p>
<p><code>Flannel</code> 是 CoreOS（Etcd 的公司）推出的一个 Overlay 类型的容器网络插件，目前支持三种后端实现：<code>UDP</code>、<code>VXLAN</code>、<code>host-gw</code> 三种方式。UDP 是最开始支持的最简单的但是却是性能最差的一种方式，因此基本上在正式使用的时候不会使用这种方式，不过该方式由于非常简单所有可以有助于我们来理解容器跨主机网络通信的实现原理，所以我们先来和大家了解下 UDP 方式的实现方式。</p>
<h2 id="udp">UDP 方式<a class="headerlink" href="#udp" title="Permanent link">&para;</a></h2>
<p>还是要 <code>UDP</code> 模式我们需要在 Flannel 的配置文件中指定 <code>Backend type</code> 为 <code>UDP</code>，可以直接修改 Flannel 的方式实现：
<pre class="highlight"><code class="language-shell">$ kubectl edit cm kube-flannel-cfg -n kube-system
apiVersion: v1
data:
  cni-conf.json: |
    {
      "cniVersion": "0.2.0",
      "name": "cbr0",
      "plugins": [
        {
          "type": "flannel",
          "delegate": {
            "hairpinMode": true,
            "isDefaultGateway": true
          }
        },
        {
          "type": "portmap",
          "capabilities": {
            "portMappings": true
          }
        }
      ]
    }
  net-conf.json: |
    {
        {
      "Network": "10.244.0.0/16",
      "Backend": {
        "Type": "udp"  # 修改后端类型为 UDP
      }
    }
kind: ConfigMap
......</code></pre></p>
<p>需要将 <code>Backend</code> 的类型更改为 <code>udp</code>，采用 UDP 模式时后端默认为端口为 8285，即 Flanneld 的监听端口。当采用 UDP 模式时，Flanneld 进程在启动时会通过打开 <code>/dev/net/tun</code> 的方式生成一个 <code>TUN</code> 设备，<code>TUN</code> 设备可以简单理解为 Linux 当中提供的一种内核网络与用户空间通信的一种机制，即应用可以通过直接读写 TUN 设备的方式收发 RAW IP 包。所以我们还需要将宿主机的 <code>/dev/net/tun</code> 文件挂载到容器中去：
<pre class="highlight"><code class="language-shell">$ kubectl edit ds kube-flannel-ds-amd64 -n kube-system
......
  volumeMounts:
    - mountPath: /run/flannel
    name: run
    - mountPath: /etc/kube-flannel/
    name: flannel-cfg
    - mountPath: /dev/net
    name: tun
......
volumes:
- hostPath:
    path: /run/flannel
    type: ""
  name: run
- hostPath:
    path: /etc/cni/net.d
    type: ""
  name: cni
- hostPath:
    path: /dev/net  # 挂载宿主机的 /dev/net/tun 文件
    type: ""
  name: tun
......</code></pre></p>
<p>然后 Flanneld 的 Pod 会自动重建，重建完成后，可以随便查看一个 Pod 的日志：
<pre class="highlight"><code class="language-shell">$ kubectl logs -f kube-flannel-ds-amd64-5bk4dmd64 -n kube-system
I1128 08:26:49.663566       1 main.go:527] Using interface with name eth0 and address 10.151.30.11
I1128 08:26:49.663838       1 main.go:544] Defaulting external address to interface address (10.151.30.11)
I1128 08:26:49.857634       1 kube.go:126] Waiting 10m0s for node controller to sync
I1128 08:26:49.857805       1 kube.go:309] Starting kube subnet manager
I1128 08:26:50.858137       1 kube.go:133] Node controller sync successful
I1128 08:26:50.858324       1 main.go:244] Created subnet manager: Kubernetes Subnet Manager - ydzs-master
I1128 08:26:50.858357       1 main.go:247] Installing signal handlers
I1128 08:26:50.858933       1 main.go:386] Found network config - Backend type: udp
I1128 08:26:51.089114       1 main.go:317] Wrote subnet file to /run/flannel/subnet.env
I1128 08:26:51.089177       1 main.go:321] Running backend.
I1128 08:26:51.089227       1 main.go:339] Waiting for all goroutines to exit
I1128 08:26:51.089280       1 udp_network_amd64.go:100] Watching for new subnet leases
I1128 08:26:51.089350       1 udp_network_amd64.go:195] Subnet added: 10.244.4.0/24
I1128 08:26:51.089443       1 udp_network_amd64.go:195] Subnet added: 10.244.1.0/24
I1128 08:26:51.089487       1 udp_network_amd64.go:195] Subnet added: 10.244.2.0/24
I1128 08:26:51.089518       1 udp_network_amd64.go:195] Subnet added: 10.244.3.0/24
I1128 08:27:01.936553       1 udp_network_amd64.go:195] Subnet added: 10.244.3.0/24
I1128 08:27:03.341176       1 udp_network_amd64.go:195] Subnet added: 10.244.4.0/24
I1128 08:27:04.136280       1 udp_network_amd64.go:195] Subnet added: 10.244.2.0/24
I1128 08:27:07.863379       1 udp_network_amd64.go:195] Subnet added: 10.244.1.0/24</code></pre></p>
<p>看到<code>Found network config - Backend type: udp</code>这个信息证明我们现在已经变成了 <code>UDP</code> 模式了。</p>
<p>Flanneld 进程启动后通过 <code>ip a</code> 命令可以发现节点当中已经多了一个叫 <code>flannel0</code> 的网络设备：
<pre class="highlight"><code class="language-shell">$ ip -d link show flannel0
210: flannel0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1472 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
    link/none  promiscuity 0
    tun addrgenmode random numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535</code></pre></p>
<p>由于是 UDP 的服务，所以我们需要通过 <code>netstat -ulnp</code> 命令查看进程：
<pre class="highlight"><code class="language-shell">$ netstat -ulnp | grep flanneld
udp        0      0 10.151.30.11:8285       0.0.0.0:*                           24844/flanneld</code></pre></p>
<p>现在我们有两个 Pod，分别在节点 ydzs-node1 和节点 ydzs-node2 上面，现在让 pod-a（10.244.1.236）向 pod-b（10.244.2.123）发送一个请求报文（ping），我们来分析以下报文是如何从 pod-a 到达 pod-b 的：
<pre class="highlight"><code class="language-shell">$ kubectl get pods -o wide
NAME                        READY   STATUS    RESTARTS   AGE     IP             NODE         NOMINATED NODE   READINESS GATES
pod-a                       1/1     Running   0          73s     10.244.1.236   ydzs-node1   &lt;none&gt;           &lt;none&gt;
pod-b                       1/1     Running   0          38s     10.244.2.123   ydzs-node2   &lt;none&gt;           &lt;none&gt;</code></pre></p>
<p>1、在 pod-a 当中发出 ICMP 请求报文，其源地址就是 10.244.1.236，目标地址是 10.244.2.123，此时通过 pod-a 内的路由表匹配到应该将该 IP 包发送到 ydzs-node1 节点上网关 10.244.1.1（<code>cni0</code>网桥）。
<pre class="highlight"><code class="language-shell">$ kubectl exec pod-a -- route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.244.1.1      0.0.0.0         UG    0      0        0 eth0
10.244.0.0      10.244.1.1      255.255.0.0     UG    0      0        0 eth0
10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 eth0</code></pre></p>
<p>在 ydzs-node1 节点上可以查看到 pod-a 中的网关 10.244.1.1 就是节点上的 <code>cni0</code> 网桥：
<pre class="highlight"><code class="language-shell">[root@ydzs-node1 ~]# ifconfig -a
cni0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450
        inet 10.244.1.1  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::64c2:65ff:fe15:3669  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether f6:f9:99:71:81:a2  txqueuelen 1000  (Ethernet)
        RX packets 33385207  bytes 24883992070 (23.1 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 31653673  bytes 19703556786 (18.3 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
......</code></pre></p>
<p>2、这个时候，IP 包的下一个目的地，就取决于宿主机上面的路由规则了，Flanneld 进程已经在宿主机上面创建了一系列的路由规则，比如当前的 ydzs-node1 节点：
<pre class="highlight"><code class="language-shell">[root@ydzs-node1 ~]# ip route
default via 10.151.30.11 dev eth0  proto static  metric 100
10.151.30.0/24 dev eth0  proto kernel  scope link  src 10.151.30.22  metric 100
10.244.0.0/16 dev flannel0
10.244.1.0/24 dev cni0  proto kernel  scope link  src 10.244.1.1
172.17.0.0/16 dev docker0  proto kernel  scope link  src 172.17.0.1</code></pre></p>
<p>此时到达 <code>cni0</code> 的 IP 包目标地址 10.244.2.123 匹配不到本机的 <code>cni0</code> 网桥对应的 <code>10.244.1.0/24</code> 网段，只能匹配到第三条 <code>10.244.0.0/16</code> 对应的这条路由规则，这个时候内核将 RAW IP 包发送给 <code>flannel0</code> 设备。</p>
<p><code>flannel0</code> 设备它是一个 <code>TUN</code> 设备（Tunnel 设备）。在 Linux 中，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备，TUN 设备的功能非常简单，即：<strong>在操作系统内核和用户应用程序之间传递 IP 包</strong>。</p>
<p>3、由于 <code>flannel0</code> 是一个 <code>TUN</code> 设备，发送给 <code>flannel0</code> 接口的 <code>RAW IP</code> 包将被 Flanneld 进程接收到，然后在原有的基础上进行 UDP 封包，然后发送到 ydzs-node2 节点上的 <code>Flanneld</code> 进行解包。</p>
<div class="admonition info">
<p class="admonition-title">封包</p>
<p>UDP 封包的形式为：10.151.30.22:src port -&gt; 10.151.30.23:8285。</p>
</div>
<p>这里最关键的就是 UDP 封包发送到我们的目标 IP 10.244.2.123 这个容器所在的节点，但是是如何知道这个节点的呢？</p>
<p>这个就需要了解一个非常重要的概念*<em>子网（Subnet）</em>，Flannel 管理的容器网络，一台宿主机上的所有容器，都属于该宿主机被分配的一个子网，比如我们这里的 ydzs-node1 节点的子网是 <code>10.244.1.0/24</code>（10.244.1.1-10.244.1.254），pod-a 的 IP 地址是 <code>10.244.1.236</code>；ydzs-node2 节点的子网是 <code>10.244.2.0/24</code>（10.244.2.1-10.244.2.254），pod-b 的 IP 地址是 <code>10.244.2.123</code>，这些子网信息是当 Flanneld 进程在启动时通过 api-server 保存到 etcd 当中，所以在发送报文时可以通过目的地址 <code>10.244.2.123</code> 匹配到对应的子网是 <code>10.244.2.0/24</code>，这个时候查询 etcd 得到这个子网对应的宿主机的 IP 地址 10.151.30.23，也就是 ydzs-node2 节点。</p>
<p>4、ydzs-node2 节点收到 UDP 报文过后经过 Linux 内核通过 UDP 端口 8285 将包交给节点上的 Flanneld 进程。</p>
<p>5、然后 ydzs-node2 节点上的 Flanneld 进程将接收到的 UDP 包解包后得到 RAW IP 包：<code>10.244.1.236 -&gt; 10.244.2.123</code>。</p>
<p>6、解包后的 RAW IP 包匹配到 ydzs-node2 节点上的路由规则（10.244.2.0/24），内核将 RAW IP 包发送给 <code>cni0</code> 设备
<pre class="highlight"><code class="language-shell">[root@ydzs-node2 ~]# ip route
default via 10.151.30.11 dev eth0  proto static  metric 100
10.151.30.0/24 dev eth0  proto kernel  scope link  src 10.151.30.23  metric 100
10.244.0.0/16 dev flannel0
10.244.2.0/24 dev cni0  proto kernel  scope link  src 10.244.2.1
172.17.0.0/16 dev docker0  proto kernel  scope link  src 172.17.0.1</code></pre></p>
<p>7、<code>cni0</code> 将 IP 包转发给连接在 <code>cni0</code> 网桥上的 pod-b，这样就完成了这个通信过程：
<pre class="highlight"><code class="language-shell">$ kubectl exec pod-a ping 10.244.2.123
PING 10.244.2.123 (10.244.2.123): 56 data bytes
64 bytes from 10.244.2.123: seq=0 ttl=62 time=1.452 ms
64 bytes from 10.244.2.123: seq=1 ttl=62 time=1.160 ms
64 bytes from 10.244.2.123: seq=2 ttl=62 time=0.853 ms</code></pre></p>
<p>上面就是基于 Flannel UDP 模式的跨主通信的基本流程了，从上面的整个流程来看，<code>Flanneld</code> 主要有两方面的功能：</p>
<ul>
<li>UDP 封包解包</li>
<li>节点上的路由表的动态更新</li>
</ul>
<p>我们可以明显看出来数据包是通过 tun 设备从内核态复制到用户态的应用中的，然后再通过用户态复制到内核态，仅一次网络传输就进行了两次用户态和内核态的切换，显然这种效率是不会很高的，由于低效率所以这种方式基本上不是呀，要提高效率最简单的方式就是把封包解包这些事情都交给内核去干好了，事实上 Linux 内核本身也提供了比较成熟的网络封包解包（隧道传输）实现方案 <code>VXLAN</code>，Flanneld 也实现了基于 <code>VXLAN</code> 的方案，该方案在我们日常使用的时候也是最普遍的。</p>
<h2 id="vxlan">VXLAN 方式<a class="headerlink" href="#vxlan" title="Permanent link">&para;</a></h2>
<p><code>VXLAN</code>，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）。</p>
<p>同样的当我们使用 <code>VXLAN</code> 模式的时候需要将 Flanneld 的 Backend 类型修改为 <code>vxlan</code>：
<pre class="highlight"><code class="language-shell">$ kubectl edit cm kube-flannel-cfg -n kube-system
apiVersion: v1
data:
  cni-conf.json: |
    {
      "cniVersion": "0.2.0",
      "name": "cbr0",
      "plugins": [
        {
          "type": "flannel",
          "delegate": {
            "hairpinMode": true,
            "isDefaultGateway": true
          }
        },
        {
          "type": "portmap",
          "capabilities": {
            "portMappings": true
          }
        }
      ]
    }
  net-conf.json: |
    {
        {
      "Network": "10.244.0.0/16",
      "Backend": {
        "Type": "vxlan"  # 修改后端类型为 vxlan
      }
    }
kind: ConfigMap
......</code></pre></p>
<p>将类型修改为 <code>vxlan</code> 过后，需要重建下 Flanneld 的所有 Pod 才能生效：
<pre class="highlight"><code class="language-shell">$ kubectl delete pod -n kube-system -l app=flannel</code></pre></p>
<p>重建完成后同样可以随便查看一个 Pod 的日志，出现如下<code>Found network config - Backend type: vxlan</code>的日志信息就证明已经配置成功了：
<pre class="highlight"><code class="language-shell">$ kubectl logs -f kube-flannel-ds-amd64-pfb8h -n kube-system
I1129 03:33:56.588549       1 main.go:527] Using interface with name eth0 and address 10.151.30.23
I1129 03:33:56.588893       1 main.go:544] Defaulting external address to interface address (10.151.30.23)
I1129 03:33:56.698562       1 kube.go:126] Waiting 10m0s for node controller to sync
I1129 03:33:56.698726       1 kube.go:309] Starting kube subnet manager
I1129 03:33:57.698910       1 kube.go:133] Node controller sync successful
I1129 03:33:57.698980       1 main.go:244] Created subnet manager: Kubernetes Subnet Manager - ydzs-node2
I1129 03:33:57.699000       1 main.go:247] Installing signal handlers
I1129 03:33:57.699375       1 main.go:386] Found network config - Backend type: vxlan
I1129 03:33:57.699553       1 vxlan.go:120] VXLAN config: VNI=1 Port=0 GBP=false DirectRouting=false
I1129 03:33:57.703715       1 main.go:317] Wrote subnet file to /run/flannel/subnet.env
I1129 03:33:57.703785       1 main.go:321] Running backend.
I1129 03:33:57.703825       1 main.go:339] Waiting for all goroutines to exit
I1129 03:33:57.703940       1 vxlan_network.go:60] watching for new subnet leases</code></pre></p>
<p>Flanneld 在启动时会通过 <code>Netlink</code> 机制与 Linux 内核通信，建立一个 <code>VTEP（Virtual Tunnel Access End Point）</code> 设备 <code>flannel.1</code>（命名规则为<code>flannel.[VNI]</code>，VNI 默认为1），类似于交换机当中的一个网口。我们可以通过 <code>ip -d link</code> 命令查看 <code>VTEP</code> 设备 <code>flannel.1</code> 的配置信息：
<pre class="highlight"><code class="language-shell">$ ip -d link show flannel.1
6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN mode DEFAULT
    link/ether 72:f7:e9:40:97:1e brd ff:ff:ff:ff:ff:ff promiscuity 0
    vxlan id 1 local 10.151.30.22 dev eth0 srcport 0 0 dstport 8472 nolearning ageing 300 addrgenmode eui64</code></pre></p>
<p>从上面输出可以看到，<code>VTEP</code> 的 local IP 为 10.151.30.22，destination port 为 <code>8472</code>。同样我们也可以在节点上查看进程监听情况：
<pre class="highlight"><code class="language-shell">$ netstat -ulnp | grep 8472
udp        0      0 0.0.0.0:8472            0.0.0.0:*                           -</code></pre></p>
<p>我们仔细看和 UDP 模式下查看 Flanneld 监听的端口是有区别的，最后一栏显示的不是进程的 ID 和名称，而是一个破折号<code>“-”</code>，这说明 UDP 的8472端口不是由用户态的进程在监听的，也证实了<code>VXLAN</code>模块工作在内核态模式下。 </p>
<p>在 UDP 模式下由 Flanneld 进程进行网络包的封包和解包的工作，而在 <code>VXLAN</code> 模式下解封包的事情交由内核处理，下面我们来看下 Flanneld 后端的具体工具流程。当 Flanneld 启动时将创建 <code>VTEP</code> 设备 <code>flannel.1</code>，并将 <code>VTEP</code> 设备的相关信息上报到 etcd 当中，而当在 Flannel 网络中有新的节点发现时，各个节点上的 Flanneld 进程将依次执行以下流程：</p>
<p>1、在节点当中创建一条该节点所属网段的路由表，主要是能让 Pod 当中的流量路由到 <code>flannel.1</code> 接口。通过<code>route -n</code>可以查看到节点当中已经有四条 <code>flannel.1</code> 接口的路由：
<pre class="highlight"><code class="language-shell">$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.151.30.11    0.0.0.0         UG    100    0        0 eth0
10.151.30.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
10.244.0.0      10.244.0.0      255.255.255.0   UG    0      0        0 flannel.1
10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0
10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1
10.244.3.0      10.244.3.0      255.255.255.0   UG    0      0        0 flannel.1
10.244.4.0      10.244.4.0      255.255.255.0   UG    0      0        0 flannel.1
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre></p>
<p>比如 <code>10.244.2.0</code> 这条路由规则，他的意思就是发往 <code>10.244.2.0/24</code> 网段的 IP 包，都需要经过 <code>flannel.1</code> 设备发出，而且最后被发送到的网关地址是 <code>10.244.2.0</code>。而其实这个网关地址就是 ydzs-node2 节点上的 VTEP 设备（也就是 flannel.1）的 IP 地址： 
<pre class="highlight"><code class="language-shell">[root@ydzs-node2 ~]# ifconfig
flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450
        inet 10.244.2.0  netmask 255.255.255.255  broadcast 0.0.0.0
        inet6 fe80::2467:52ff:fe6b:1bf9  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 26:67:52:6b:1b:f9  txqueuelen 0  (Ethernet)
        RX packets 42050890  bytes 27691009839 (25.7 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 36287976  bytes 46894346975 (43.6 GiB)
        TX errors 0  dropped 163 overruns 0  carrier 0  collisions 0
......</code></pre></p>
<p>2、上面知道了目的 VTEP 设备的 IP 地址了，这个时候就需要知道目的 MAC 地址，才能把数据包发送过去，这个时候其实 Flanneld 进程就会在节点当中维护所有节点的 IP 以及 <code>VTEP</code> 设备的静态 <code>ARP</code> 缓存。可通过 <code>arp -n</code> 命令查看到当前节点当中已经缓存了另外四个节点以及 <code>VTEP</code> 的 ARP 信息。
<pre class="highlight"><code class="language-shell">$ arp -n
Address                  HWtype  HWaddress           Flags Mask            Iface
10.244.3.0               ether   32:f1:e0:a9:97:ab   CM                    flannel.1
10.244.2.0               ether   26:67:52:6b:1b:f9   CM                    flannel.1
10.244.0.0               ether   0a:24:5e:40:ff:da   CM                    flannel.1
10.244.4.0               ether   4a:09:1f:42:ed:c1   CM                    flannel.1
......</code></pre></p>
<p>这里我们可以看到 IP 地址 <code>10.244.2.0</code> 对应的 MAC 地址是 <code>26:67:52:6b:1b:f9</code>，这样我们就知道了目的 VTEP 设备的 MAC 地址。但是现在我们只是知道了目标设备的 MAC 地址，却不知道对应的宿主机的地址是什么？</p>
<p>3、这个时候 Flanneld 进程还会在节点当中添加一条该节点的转发表，通过 <code>bridge</code> 命令查看节点上的 VXLAN 转发表（FDB entry），MAC 为 <code>VTEP</code> 设备即 <code>flannel.1</code> 的 MAC 地址，IP 为 VTEP 对应的对外 IP（可通过 Flanneld 的启动参数 <code>--iface=eth0</code> 指定，若不指定则按默认网关查找网络接口对应的 IP），可以看到已经有四条转发表。
<pre class="highlight"><code class="language-shell">$ bridge fdb show dev flannel.1
32:f1:e0:a9:97:ab dst 10.151.30.57 self permanent
26:67:52:6b:1b:f9 dst 10.151.30.23 self permanent
4a:09:1f:42:ed:c1 dst 10.151.30.59 self permanent
0a:24:5e:40:ff:da dst 10.151.30.11 self permanent</code></pre></p>
<p>这样我们就找到了上面目的 VTEP 设备的 MAC 地址对应的 IP 地址为 10.151.30.23 的主机，这就是我们的 ydzs-node2 节点，所以我们就找到了要发往的目的地址。</p>
<p>这个时候容器跨节点网络通信实现的完整流程为：</p>
<ul>
<li>和 UDP 模式一样，pod-a（10.244.1.236）当中的 IP 包通过 pod-a 内的路由表被发送到 <code>cni0</code></li>
<li>到达 <code>cni0</code> 当中的 IP 包通过匹配节点 ydzs-node1 当中的路由表发现通往 10.244.2.13 的 IP 包应该交给 <code>flannel.1</code> 接口</li>
<li><code>flannel.1</code> 作为一个 VTEP 设备，收到报文后将按照 <code>VTEP</code> 的配置进行封包，通过 ydzs-node1 节点上的 arp 和转发表得知 10.244.2.123 属于节点 ydzs-node2，并且会将 ydzs-node2 节点对应的 VTEP 设备的 MAC 地址，根据 <code>flannel.1</code> 设备创建时的设置的参数（VNI、local IP、Port）进行 VXLAN 封包</li>
<li>通过节点 ydzs-node2 跟 ydzs-node1 之间的网络连接，VXLAN 包到达 ydzs-node2 的 eth0 接口</li>
<li>通过端口 8472，VXLAN 包被转发给 VTEP 设备 <code>flannel.1</code> 进行解包</li>
<li>解封装后的 IP 包匹配节点 ydzs-node2 当中的路由表（10.244.2.0），内核将 IP 包转发给<code>cni0</code></li>
<li><code>cni0</code>将 IP 包转发给连接在 <code>cni0</code> 上的 pod-b</li>
</ul>
<h2 id="host-gw">host-gw<a class="headerlink" href="#host-gw" title="Permanent link">&para;</a></h2>
<p><code>host-gw</code> 即 Host Gateway，从名字中就可以想到这种方式是通过把主机当作网关来实现跨节点网络通信的。那么具体如何实现跨节点通信呢？</p>
<p>同理 UDP 模式和 VXLAN 模式，首先将 Backend 中的 type 改为<code>host-gw</code>，这里就不再赘述，更新完成后，随便查看一个 flannel 的 Pod 日志，如果出现如下所示的 <code>Found network config - Backend type: host-gw</code> 日志就证明已经是 <code>host-gw</code> 模式了：
<pre class="highlight"><code class="language-shell">$ kubectl logs -f kube-flannel-ds-amd64-642l6 -n kube-system
I1129 04:53:34.309992       1 main.go:527] Using interface with name eth0 and address 10.151.30.59
I1129 04:53:34.310292       1 main.go:544] Defaulting external address to interface address (10.151.30.59)
I1129 04:53:34.510618       1 kube.go:126] Waiting 10m0s for node controller to sync
I1129 04:53:34.607860       1 kube.go:309] Starting kube subnet manager
I1129 04:53:35.511530       1 kube.go:133] Node controller sync successful
I1129 04:53:35.511624       1 main.go:244] Created subnet manager: Kubernetes Subnet Manager - ydzs-node4
I1129 04:53:35.511646       1 main.go:247] Installing signal handlers
I1129 04:53:35.511899       1 main.go:386] Found network config - Backend type: host-gw
I1129 04:53:35.611040       1 main.go:317] Wrote subnet file to /run/flannel/subnet.env
I1129 04:53:35.611120       1 main.go:321] Running backend.
I1129 04:53:35.611165       1 main.go:339] Waiting for all goroutines to exit
I1129 04:53:35.611280       1 route_network.go:53] Watching for new subnet leases
I1129 04:53:35.611768       1 route_network.go:85] Subnet added: 10.244.0.0/24 via 10.151.30.11
W1129 04:53:35.612268       1 route_network.go:102] Replacing existing route to 10.244.0.0/24 via 10.244.0.0 dev index 6 with 10.244.0.0/24 via 10.151.30.11 dev index 2.
I1129 04:53:35.612705       1 route_network.go:85] Subnet added: 10.244.1.0/24 via 10.151.30.22
W1129 04:53:35.612777       1 route_network.go:88] Ignoring non-host-gw subnet: type=vxlan
I1129 04:53:35.612829       1 route_network.go:85] Subnet added: 10.244.2.0/24 via 10.151.30.23
W1129 04:53:35.612868       1 route_network.go:88] Ignoring non-host-gw subnet: type=vxlan
I1129 04:53:35.612935       1 route_network.go:85] Subnet added: 10.244.3.0/24 via 10.151.30.57
W1129 04:53:35.612995       1 route_network.go:88] Ignoring non-host-gw subnet: type=vxlan
I1129 04:53:35.808989       1 route_network.go:85] Subnet added: 10.244.3.0/24 via 10.151.30.57
W1129 04:53:35.809279       1 route_network.go:102] Replacing existing route to 10.244.3.0/24 via 10.244.3.0 dev index 6 with 10.244.3.0/24 via 10.151.30.57 dev index 2.
I1129 04:53:37.012832       1 route_network.go:85] Subnet added: 10.244.1.0/24 via 10.151.30.22
W1129 04:53:37.013132       1 route_network.go:102] Replacing existing route to 10.244.1.0/24 via 10.244.1.0 dev index 6 with 10.244.1.0/24 via 10.151.30.22 dev index 2.
I1129 04:53:37.713684       1 route_network.go:85] Subnet added: 10.244.2.0/24 via 10.151.30.23
W1129 04:53:37.714022       1 route_network.go:102] Replacing existing route to 10.244.2.0/24 via 10.244.2.0 dev index 6 with 10.244.2.0/24 via 10.151.30.23 dev index 2.</code></pre></p>
<p>采用 <code>host-gw</code> 模式后 Flanneld 的唯一作用就是<strong>负责主机上路由表的动态更新</strong>，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的<code>“下一跳”</code>，设置成了该子网对应的宿主机的 IP 地址，当然，Flannel 子网和主机的信息，都是保存在 etcd 当中的。Fanneld 只需要 WACTH 这些数据的变化，然后实时更新路由表即可。主要流程如下所示：</p>
<p>1、同 UDP、VXLAN 模式一致，通过容器A 的路由表 IP 包到达<code>cni0</code>
2、到达 <code>cni0</code> 的 IP 包匹配到 ydzs-node1 当中的路由规则（10.244.2.0），并且网关为 10.151.30.23，即节点 ydzs-node2，所以内核将 IP 包发送给节点 ydzs-node2（10.151.30.23）:
<pre class="highlight"><code class="language-shell">$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.151.30.11    0.0.0.0         UG    100    0        0 eth0
10.151.30.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
10.244.0.0      10.151.30.11    255.255.255.0   UG    0      0        0 eth0
10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0
10.244.2.0      10.151.30.23    255.255.255.0   UG    0      0        0 eth0
10.244.3.0      10.151.30.57    255.255.255.0   UG    0      0        0 eth0
10.244.4.0      10.151.30.59    255.255.255.0   UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre></p>
<p>3、IP 包通过物理网络到达节点的 ydzs-node2 的 eth0 设备
4、到达 ydzs-node2 节点 eth0 的 IP 包匹配到节点当中的路由表（10.244.2.0/24），IP 包被转发给 <code>cni0</code> 设备
5、<code>cni0</code> 将 IP 包转发给连接在 <code>cni0</code> 上的 pod-b</p>
<p>这样就完成了整个跨主机通信流程，这个流程可能是最简单最容器理解的模式了，而且容器通信的过程还免除了额外的封包和解包带来的性能损耗，所以理论上性能肯定要更好，但是该模式是通过节点上的<strong>路由表</strong>来实现各个节点之间的跨节点网络通信，那么就得保证两个节点是可以<strong>直接路由</strong>过去的。按照内核当中的路由规则，网关必须在跟主机当中至少一个 IP 处于同一网段，故造成的结果就是采用<code>host-gw</code> 这种模式的时候，集群中所有的节点必须处于同一个网络当中，这对于集群规模比较大时需要对节点进行网段划分的话会存在一定的局限性，另外一个则是随着集群当中节点规模的增大，Flanneld 需要维护主机上成千上万条路由表的动态更新也是一个不小的压力。</p>
<p>除了 Flannel 之外，<code>Calico</code> 这种网络插件和 Flannel 的 <code>host-gw</code> 模式基本上是一样的，都是在每台书主机上面添加子网和对应的书主机的 IP 地址为网关这样的路由信息，不过，不同于 Flannel 通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 使用 <code>bgp</code> 来自动地在整个集群中分发路由信息。</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      



<!-- Application footer -->
<footer class="md-footer">

    <!-- Further information -->
    <div class="md-footer-meta md-typeset">
        <div class="md-footer-meta__inner md-grid">

            <!-- Copyright and theme information -->
            <div class="md-footer-copyright">
                
                <div class="md-footer-copyright__highlight">
                    Copyright &copy; 2020 Kubernetes技术栈
                </div>
                
                powered by
                <a href="https://www.k8stech.net" title="Kubernetes技术栈">www.k8stech.net</a>
            </div>

            <!-- Social links -->
            
            
            
        </div>
    </div>
</footer>


    </div>
    
      <script src="../../assets/javascripts/application.d9aa80ab.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.jp.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="../../assets/js/hljs/highlight.pack.js"></script>
      
        <script src="../../assets/js/prism.js"></script>
      
    
  </body>
</html>