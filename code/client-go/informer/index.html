
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="canonical" href="https://docs.prometheus.cool/code/client-go/informer/">
      
      <link rel="icon" href="../../../assets/img/prometheus_logo.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.4">
    
    
      
        <title>Informer - 云原生监控神器Prometheus</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.db9e7362.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#ef5552">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700%7CUbuntu+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Ubuntu";--md-code-font-family:"Ubuntu Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../../../assets/styles/extra.css">
    
      <link rel="stylesheet" href="../../../assets/styles/prism.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="red" data-md-color-accent="red">
  
    
    <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#informer" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="云原生监控神器Prometheus" class="md-header__button md-logo" aria-label="云原生监控神器Prometheus" data-md-component="logo">
      
  <img src="../../../assets/img/prometheus_logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            云原生监控神器Prometheus
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Informer
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/k8stech/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="云原生监控神器Prometheus" class="md-nav__button md-logo" aria-label="云原生监控神器Prometheus" data-md-component="logo">
      
  <img src="../../../assets/img/prometheus_logo.png" alt="logo">

    </a>
    云原生监控神器Prometheus
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/k8stech/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        介绍
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          监控基础与概述
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="监控基础与概述" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          监控基础与概述
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../monitorbasic/whymonitor/" class="md-nav__link">
        为什么要监控
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../monitorbasic/monitorterms/" class="md-nav__link">
        监控术语
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../monitorbasic/metricstory/" class="md-nav__link">
        指标物语
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../monitorbasic/monitorcontrast/" class="md-nav__link">
        开源监控对比
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Prometheus 基础
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus 基础" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Prometheus 基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../basic/prom-introduction/" class="md-nav__link">
        Prometheus介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../basic/tsdb-contrast/" class="md-nav__link">
        时序数据库对比
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../basic/prom-datamodel/" class="md-nav__link">
        数据模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../basic/node-exporter/" class="md-nav__link">
        Node_Exporter
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../basic/prom-config/" class="md-nav__link">
        Prometheus安装与配置
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          Prometheus 进阶
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus 进阶" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Prometheus 进阶
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../advanced/auto-ops-exporter-1/" class="md-nav__link">
        自动化维护Exporter（一）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../advanced/auto-ops-exporter-2/" class="md-nav__link">
        自动化维护Exporter（二）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../advanced/docker-swarm-monitor-1/" class="md-nav__link">
        Docker-Swarm集群监控（一）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../advanced/docker-swarm-monitor-2/" class="md-nav__link">
        Docker-Swarm集群监控（二）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../advanced/commonly-exporter/" class="md-nav__link">
        常用Exporter介绍与配置
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          Prometheus(警报)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus(警报)" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Prometheus(警报)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/promql-basic/" class="md-nav__link">
        PromQL详解（一）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/promql-operator/" class="md-nav__link">
        PromQL详解（二）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/promql-operator2/" class="md-nav__link">
        PromQL详解（三）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/promql-function/" class="md-nav__link">
        PromQL函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/alertmanager-overview/" class="md-nav__link">
        AlertManager
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/alertmanager-rules-1/" class="md-nav__link">
        Rules详解（一）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/alertmanager-rules-2/" class="md-nav__link">
        Rules详解（二）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/alertmanager-receiver/" class="md-nav__link">
        Receiver配置
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Alertmanager/alertmanager-silences/" class="md-nav__link">
        Silences配置
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          Prometheus(联邦集群)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus(联邦集群)" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Prometheus(联邦集群)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../federation/federation-overview/" class="md-nav__link">
        Prometheus 联邦集群
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../federation/pushgateway/" class="md-nav__link">
        Pushgateway 代理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../federation/alertmanager-ha/" class="md-nav__link">
        Alertmanager 高可用
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          Prometheus(服务发现)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus(服务发现)" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Prometheus(服务发现)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../discover-service/discovery-overview/" class="md-nav__link">
        服务发现（文件、DNS）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../discover-service/discovery-relabeling/" class="md-nav__link">
        服务发现（Relabelling）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../discover-service/discovery-consul/" class="md-nav__link">
        服务发现（Consul）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" >
      
      
      
      
        <label class="md-nav__link" for="__nav_8">
          Prometheus(Operator)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Prometheus(Operator)" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          Prometheus(Operator)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Operator/" class="md-nav__link">
        Operator概述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Statefulsets-1/" class="md-nav__link">
        手动部署（1）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Statefulsets-2/" class="md-nav__link">
        手动部署（2）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Statefulsets-3/" class="md-nav__link">
        手动部署（联邦）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Deploy-Operator/" class="md-nav__link">
        Operator部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-HPA/" class="md-nav__link">
        HPA原理与实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Kubernetes/Prometheus-Adapter/" class="md-nav__link">
        Adapter原理与实践
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#listwatch" class="md-nav__link">
    ListWatch
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reflector" class="md-nav__link">
    Reflector
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#controller" class="md-nav__link">
    Controller
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shareinformer" class="md-nav__link">
    ShareInformer
  </a>
  
    <nav class="md-nav" aria-label="ShareInformer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sharedprocessor" class="md-nav__link">
    sharedProcessor
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/k8stech/edit/master/docs/code/client-go/informer.md" title="编辑此页" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="informer">Informer<a class="headerlink" href="#informer" title="Permanent link">&para;</a></h1>
<p>Informer（就是 SharedInformer）可以说是 client-go 中最重要的组成部分。主要由 Reflector、DeltaFIFO、Local Store、WorkQueue 几个组件组成，以下是 Informer 的工作流程：</p>
<p><img alt="informer workflow" src="../../../assets/img/code/informer-workflow.png" /></p>
<p>根据流程图以及前面的知识点串联起来解释一下 Informer 中几个组件的作用：</p>
<ul>
<li>
<p>Reflector：称之为反射器，实现对 apiserver 指定类型对象的监控(ListAndWatch)，其中反射实现的就是把监控的结果实例化成具体的对象，最终也是调用 Kubernetes 的 List/Watch API；</p>
</li>
<li>
<p>DeltaIFIFO Queue：一个增量队列，将 Reflector 监控变化的对象形成一个 FIFO 队列，此处的 Delta 就是变化；</p>
</li>
<li>
<p>LocalStore：就是 informer 的 cache，这里面缓存的是 apiserver 中的对象(其中有一部分可能还在DeltaFIFO 中)，此时使用者再查询对象的时候就直接从 cache 中查找，减少了 apiserver 的压力，LocalStore 只会被 Lister 的 List/Get 方法访问。</p>
</li>
<li>
<p>WorkQueue：DeltaIFIFO 收到事件后会先将事件存储在自己的数据结构中，然后直接操作 Store 中存储的数据，更新完 store 后 DeltaIFIFO 会将该事件 pop 到 WorkQueue 中，Controller 收到 WorkQueue 中的事件会根据对应的类型触发对应的回调函数。</p>
</li>
</ul>
<!-- Shared 指的是多个 listeners 共享同一个 cache，而且资源的变化会同时通知到 cache 和 listeners。这个解释和上面图所展示的内容的是一致的，cache 我们在 Indexer 的介绍中已经分析过了，listeners 指的就是 OnAdd、OnUpdate、OnDelete 这些回调函数背后的对象。我们先对上面的图做一些初步的认识：

* List/Watch：List 是列举 apiserver 中资源对象的接口，Watch 是监控 apiserver 资源变化的接口
* Reflector：我们可以称之为反射器，实现对 apiserver 指定类型对象的监控，其中反射实现的就是把监控的结果实例化成具体的对象
* DeltaIFIFO：将 Reflector 监控的变化的对象形成一个 FIFO 队列，Delta 就是变化，DeltaFIFO 就是变化的一个 FIFO 队列
* LocalStore：指的就是 Indexer 的实现 cache，这里面缓存的就是 apiserver 中的对象（其中有一部分可能还在 DeltaFIFO中），此时使用者再查询对象的时候就直接从 cache 中查找，减少了 apiserver 的压力
* Callbacks：通知回调函数，Infomer 感知的所有对象变化都是通过回调函数通知使用者（Listener） -->

<ul>
<li>Informer 首先会 list/watch apiserver，Informer 所使用的 Reflector 包负责与 apiserver 建立连接，Reflector 使用 ListAndWatch 的方法，会先从 apiserver 中 list 该资源的全量对象，list 会拿到该对象最新的 resourceVersion，然后使用 watch 方法监听该 resourceVersion 之后的所有变化，若中途出现异常，Reflector 则会从断开的 resourceVersion 处重现尝试监听所有变化，一旦该对象的实例有创建、删除、更新动作，Reflector 都会收到“事件通知”，这时该事件及它对应的资源对象这个组合，被称为增量（Delta），它会被放进 DeltaFIFO 中。</li>
<li>Informer 会不断地从这个 DeltaFIFO 中读取增量，每拿出一个对象，Informer 就会判断这个增量的事件类型，然后创建或更新本地的缓存，也就是 store。</li>
<li>如果事件类型是 Added（添加对象），那么 Informer 会通过 Indexer 的库把这个增量的资源对象保存到本地的缓存中，并为它创建索引，若为删除操作，则在本地缓存中删除该对象。</li>
<li>DeltaFIFO 再 pop 这个事件到 controller 中，controller 会调用事先注册的 ResourceEventHandler 回调函数进行处理。</li>
<li>在 ResourceEventHandler 回调函数中，其实只是做了一些很简单的过滤，然后将关心变更的 Object 放到 workqueue 里面。</li>
<li>Controller 从 workqueue 里面取出 Object，启动一个 worker 来执行自己的业务逻辑，业务逻辑通常是计算目前集群的状态和用户希望达到的状态有多大的区别，然后孜孜不倦地让 apiserver 将状态演化到用户希望达到的状态，比如为 deployment 创建新的 pods，或者是扩容/缩容 deployment。</li>
<li>在 worker 中就可以使用 lister 来获取 resource，而不用频繁的访问 apiserver，因为 apiserver 中 resource 的变更都会反映到本地的 cache 中。</li>
</ul>
<h2 id="listwatch">ListWatch<a class="headerlink" href="#listwatch" title="Permanent link">&para;</a></h2>
<p>Lister 用于获取某个资源的（如 Pod）的全量，Watcher 用于获取某个资源的增量变化。实际上使用中 Lister 和 Watcher 都从 apiserver 获取资源信息，Lister 一般用于首次获取某资源（如 Pod）的全量信息，而 Watcher 用于持续获取该资源的增量变化信息。Lister 和 Watcher 的接口定义如下所示：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/listwatch.go
// Lister 是知道如何执行初始化列表的任意对象
type Lister interface {
    // 根据选项列举对象，ListOptions 定义在 apimachinery 包下面
    List(options metav1.ListOptions) (runtime.Object, error)
}

// Watcher 是知道如何在资源上开始watch的任意对象
type Watcher interface {
    // 根据选项监控对象变化
    Watch(options metav1.ListOptions) (watch.Interface, error)
}

// Lister 和 Watcher 的组合
type ListerWatcher interface {
    Lister
    Watcher
}</code></pre></p>
<p>可以直接通过 <code>NewListWatchFromClient</code> 函数进行初始化 ListerWatcher：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/listwatch.go
// NewListWatchFromClient 从指定的 client、资源、namespace 和字段 selector
func NewListWatchFromClient(c Getter, resource string, namespace string, fieldSelector fields.Selector) *ListWatch {
    optionsModifier := func(options *metav1.ListOptions) {
        options.FieldSelector = fieldSelector.String()
    }
    // 实现在下面的函数中
    return NewFilteredListWatchFromClient(c, resource, namespace, optionsModifier)
}

func NewFilteredListWatchFromClient(c Getter, resource string, namespace string, optionsModifier func(options *metav1.ListOptions)) *ListWatch {
    listFunc := func(options metav1.ListOptions) (runtime.Object, error) {
        optionsModifier(&amp;options)
        return c.Get().
            Namespace(namespace).
            Resource(resource).
            VersionedParams(&amp;options, metav1.ParameterCodec).
            Do().
            Get()
    }
    watchFunc := func(options metav1.ListOptions) (watch.Interface, error) {
        options.Watch = true
        optionsModifier(&amp;options)
        return c.Get().
            Namespace(namespace).
            Resource(resource).
            VersionedParams(&amp;options, metav1.ParameterCodec).
            Watch()
    }
    return &amp;ListWatch{ListFunc: listFunc, WatchFunc: watchFunc}
}</code></pre></p>
<p>我们只要知道 ListerWatcher 是通过 apiserver 的 API 来列举和监控的就行了，具体是如何实现的其实当前来看并不重要。需要注意一点：ListerWatcher 是针对某一类对象的，比如 Pod，不是所有对象的，这个在构造ListerWatcher 对象的时候由 apiserver 的 client 类型决定了。比如在 workqueue 的例子中我们就可以看到初始化 ListWatcher 的方法：
<pre class="highlight"><code class="language-go">// client-go/examples/workqueue/main.go
// create the pod watcher
podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), "pods", v1.NamespaceDefault, fields.Everything())</code></pre></p>
<p><code>clientset.CoreV1().RESTClient()</code> 就是来获取我们的 client 的，不过返回值是一个 Interface 的接口类型：
<pre class="highlight"><code class="language-go">// client-go/rest/client.go
// Interface 包含于 kubernetes rest api 进行交换的操作集合
type Interface interface {
    GetRateLimiter() flowcontrol.RateLimiter
    Verb(verb string) *Request
    Post() *Request
    Put() *Request
    Patch(pt types.PatchType) *Request
    Get() *Request
    Delete() *Request
    APIVersion() schema.GroupVersion
}</code></pre></p>
<p><code>pods</code> 表示我们要获取 Pod 资源的相关数据。这样我们可以获取了可以列举全量 Pod 资源和 Watch Pod 资源增量变化的 ListWatcher 对象了。</p>
<h2 id="reflector">Reflector<a class="headerlink" href="#reflector" title="Permanent link">&para;</a></h2>
<p>reflector 使用 ListerWatcher 获取资源，并将其保存在 store 中，此处的 store 就是 DeltaFIFO，Reflector 核心处理函数为 ListAndWatch：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/reflector.go
// Reflector watch 指定的资源并将所有的改变都反射到给定的 store 中
type Reflector struct {
    name string  // reflector 名称
    // metrics tracks basic metric information about the reflector
    metrics *reflectorMetrics

    expectedType reflect.Type  // 反射的类型，也就是要监控的对象类型，比如 Pod
    store Store  // 存储，也就是 DeltaFIFO
    listerWatcher ListerWatcher  // 用来从 apiserver 获取资源
    period       time.Duration  // reflector在list和watch的时候理论上是死循环，只有出现错误才会退出
                                // 这个变量用在出错后多长时间再执行List和Watch，默认是1s
    resyncPeriod time.Duration  // 重新同步的周期，指的是 shared_informer 使用者需要定期同步全量对象
    ShouldResync func() bool  // 如果需要同步，调用这个函数询问以下
    clock clock.Clock           // 时钟
    lastSyncResourceVersion string  // 最后一次同步的资源版本
    lastSyncResourceVersionMutex sync.RWMutex  // 最后一次同步资源的锁
    WatchListPageSize int64  // 请求初始化和重新同步 watch 列表的请求 chunk 大小，默认为 pager.PageSize
}</code></pre></p>
<ul>
<li>listerWatcher 用于获取和监控资源，lister 可以获取对象的全量，watcher 可以获取对象的增量(变化)</li>
<li>系统会周期性的执行 list-watch 的流程，一旦过程中失败就要重新执行流程，这个重新执行的周期就是 period 指定的</li>
<li>expectedType 规定了监控对象的类型，非此类型的对象将会被忽略</li>
<li>实例化后的 expectedType 类型的对象会被添加到 store 中</li>
<li>kubernetes 资源在 apiserver 中都是有版本的，对象的任何除了修改(添加、删除、更新)都会造成资源版本更新，所以 lastSyncResourceVersion 就是指的这个版本</li>
<li>如果使用者需要定期同步全量对象，那么 Reflector 就会定期产生全量对象的同步事件给 DeltaFIFO</li>
</ul>
<p>ListAndWatch 在 <code>Reflector.Run</code> 函数中启动，并以 <code>Reflector.period</code> 周期性进行调度。ListAndWatch 使用 resourceVersion 来获取资源的增量变化：在 List 时会获取资源的首个 resourceVersion 值，在 Watch 的时候会使用 List 获取的 resourceVersion 来获取资源的增量变化，然后将获取到的资源的 resourceVersion 保存起来，作为下一次 Watch 的基线。
<pre class="highlight"><code class="language-go">// client-go/tools/cache/reflector.go
// Run 开启一个 watch 有 watch 事件的处理器。如果关闭了会重启 watch，stopCh 关闭的时候会退出 Run
func (r *Reflector) Run(stopCh &lt;-chan struct{}) {
    klog.V(3).Infof("Starting reflector %v (%s) from %s", r.expectedType, r.resyncPeriod, r.name)
    // wait.Until 调用函数 f 会被每 period 周期执行一次
    // 意思就是f()函数执行完毕再等period时间后在执行一次，也就是r.ListAndWatch()会被周期性的调用
    wait.Until(func() {
        if err := r.ListAndWatch(stopCh); err != nil {
            utilruntime.HandleError(err)
        }
    }, r.period, stopCh)
}</code></pre></p>
<p>可以看到这里使用 <code>wait.Until</code> 每隔 period 就会调用一次 ListAndWatch，接下来看这个核心的函数：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/reflector.go
// ListAndWatch 首先列举所有元素并在调用时获取资源版本，然后使用资源版本进行 watch。
// 如果 ListAndWatch 都没有尝试初始化 watch，将会返回 error
func (r *Reflector) ListAndWatch(stopCh &lt;-chan struct{}) error {
    klog.V(3).Infof("Listing and watching %v from %s", r.expectedType, r.name)
    var resourceVersion string
    // 很多存储类的系统都是这样设计的，数据采用版本的方式记录，数据每变化(添加、删除、更新)都会触发版本更新，
    // 这样的做法可以避免全量数据访问。以 apiserver 资源监控为例，只要监控比缓存中资源版本大的对象就可以了，
    // 把变化的部分更新到缓存中就可以达到与 apiserver 一致的效果，一般资源的初始版本为0，从0版本开始列举就是全量的对象了
    options := metav1.ListOptions{ResourceVersion: "0"}

    if err := func() error {
        initTrace := trace.New("Reflector " + r.name + " ListAndWatch")
        defer initTrace.LogIfLong(10 * time.Second)
        var list runtime.Object
        var err error
        listCh := make(chan struct{}, 1)
        panicCh := make(chan interface{}, 1)
        go func() {
            defer func() {
                if r := recover(); r != nil {
                    panicCh &lt;- r
                }
            }()
            // 如果 listerWatcher 支持，则尝试使用 chunks 的形式收集 list 列表，如果不支持，则第一个列表请求将返回所有的response。
            pager := pager.New(pager.SimplePageFunc(func(opts metav1.ListOptions) (runtime.Object, error) {
                // 根据opts列举资源，在 apimachery 中实现的
                return r.listerWatcher.List(opts)
            }))
            if r.WatchListPageSize != 0 {
                pager.PageSize = r.WatchListPageSize
            }
            // 如果分页列表调用由于“Expired”错误而失败，则 Pager 将返回完整的列表。
            list, err = pager.List(context.Background(), options)
            close(listCh)
        }()
        select {
        case &lt;-stopCh:
            return nil
        case r := &lt;-panicCh:
            panic(r)
        case &lt;-listCh:
        }
        if err != nil {
            return fmt.Errorf("%s: Failed to list %v: %v", r.name, r.expectedType, err)
        }
        initTrace.Step("Objects listed")
        // 把列举返回的结果转换为对象数组
        listMetaInterface, err := meta.ListAccessor(list)
        if err != nil {
            return fmt.Errorf("%s: Unable to understand list result %#v: %v", r.name, list, err)
        }
        // 获取资源版本
        resourceVersion = listMetaInterface.GetResourceVersion()
        initTrace.Step("Resource version extracted")
        items, err := meta.ExtractList(list)
        if err != nil {
            return fmt.Errorf("%s: Unable to understand list result %#v (%v)", r.name, list, err)
        }
        initTrace.Step("Objects extracted")
        // 以上部分都是对象实例化的过程，可以称之为反射，下面是真正从 apiserver 同步过来的全量对象，所以要同步到 DeltaFIFO 中
        if err := r.syncWith(items, resourceVersion); err != nil {
            return fmt.Errorf("%s: Unable to sync list result: %v", r.name, err)
        }
        initTrace.Step("SyncWith done")
        // 设置最新的同步的对象版本
        r.setLastSyncResourceVersion(resourceVersion)
        initTrace.Step("Resource version updated")
        return nil
    }(); err != nil {
        return err
    }

    // 下面要启动一个后台协程实现定期的同步操作，这个同步就是将 SharedInformer 里面的对象全量以同步事件的方式通知使用者
    // 我们暂且称之为“后台同步协程”，Run() 函数退出需要后台同步协程退出，所以下面的 cancelCh 就是干这个用的
    // 利用 defer close(cancelCh) 实现的，而 resyncerrc 是后台同步协程反向通知 Run() 函数的报错通道
    // 当后台同步协程出错，Run() 函数接收到信号就可以退出了
    resyncerrc := make(chan error, 1)
    cancelCh := make(chan struct{})
    defer close(cancelCh)
    go func() {
        // resyncCh 返回的就是一个定时器，如果resyncPeriod为0那么就会返回一个永久定时器
        // cleanup 函数是用来清理定时器的
        resyncCh, cleanup := r.resyncChan()
        defer func() {
            cleanup() // Call the last one written into cleanup
        }()
        for {
            select {
            case &lt;-resyncCh:
            case &lt;-stopCh:
                return
            case &lt;-cancelCh:
                return
            }
            // ShouldResync 是一个函数地址，创建反射器对象的时候传入，即便时间到了，也要通过函数问问是否需要同步
            if r.ShouldResync == nil || r.ShouldResync() {
                klog.V(4).Infof("%s: forcing resync", r.name)
                // store 就是 DeltaFIFO，调用 DeltaFIFO.Resync()
                // 在这里实现了我们前面提到的同步，从这里看所谓的同步就是以全量对象同步事件的方式通知使用者
                if err := r.store.Resync(); err != nil {
                    resyncerrc &lt;- err
                    return
                }
            }
            // 清理掉当前的计时器，获取下一个同步时间定时器
            cleanup()
            resyncCh, cleanup = r.resyncChan()
        }
    }()

    // 前面是列举全量对象，下面是 watch 的逻辑
    for {
        select {
        case &lt;-stopCh:
            return nil
        default:
        }
        // 计算 watch 的超时时间
        timeoutSeconds := int64(minWatchTimeout.Seconds() * (rand.Float64() + 1.0))
        // 设置 watch 的选项，因为前面列举了全量对象，从这里只要监听最新版本以后的资源就可以了
        // 如果没有资源变化总不能一直挂着吧？也不知道是卡死了还是怎么了，所以有一个超时会好一点
        options = metav1.ListOptions{
            ResourceVersion: resourceVersion,
            TimeoutSeconds: &amp;timeoutSeconds,
            // 要减少 kube-apiserver 在 watch 重启时的负载，可以启用 watch 书签。
            AllowWatchBookmarks: false,
        }
        // 开始监控对象
        w, err := r.listerWatcher.Watch(options)
        // watch 产生了错误，大部分错误就要退出函数然后再重新来一遍流程
        if err != nil {
            switch err {
            case io.EOF:
            case io.ErrUnexpectedEOF:
                klog.V(1).Infof("%s: Watch for %v closed with unexpected EOF: %v", r.name, r.expectedType, err)
            default:
                utilruntime.HandleError(fmt.Errorf("%s: Failed to watch %v: %v", r.name, r.expectedType, err))
            }
            // 类似于网络拒绝连接的错误要等一会儿再试，因为可能网络繁忙
            if urlError, ok := err.(*url.Error); ok {
                if opError, ok := urlError.Err.(*net.OpError); ok {
                    if errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED {
                        time.Sleep(time.Second)
                        continue
                    }
                }
            }
            return nil
        }
        // watch 返回的是 stream流， apiserver 会将变化的资源通过这个流发送出来，client-go 最终通过 channel 实现的
        // 所以 watchHandler() 是一个需要持续从 channel 读取数据的流程，所以需要传入 resyncerrc 和 stopCh 用于异步通知
        // 退出或者后台同步协程错误
        if err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != nil {
            if err != errorStopRequested {
                klog.Warningf("%s: watch of %v ended with: %v", r.name, r.expectedType, err)
            }
            return nil
        }
    }
}</code></pre></p>
<p>上面的函数中，调用了两个私有函数，分别为 <code>syncWith()</code> 和 <code>watchHandler()</code>。<code>syncWith()</code> 用于实现一次从 apiserver 全量对象的同步，这里的同步和我们上面提到的同步不是一回事，这里指的是从 apiserver 的同步。watchHandler 是实现监控 apiserver 资源变化的处理过程，主要就是把 apiserver 的资源变化转换为 DeltaFIFO 调用。我们接下来就看这两个函数的具体实现：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/reflector.go
// syncWith 用给定的 list 替换 store 中的 items 元素，实现 apiserver 全量对象的同步
func (r *Reflector) syncWith(items []runtime.Object, resourceVersion string) error {
    // 实际上就是做一次 slice 类型转换，变成 interface{} 类型
    found := make([]interface{}, 0, len(items))
    for _, item := range items {
        found = append(found, item)
    }
    // 直接调用 DeltaFIFO 的 Replace() 函数，用于同步全量对象
    return r.store.Replace(found, resourceVersion)
}

// 实现从 watch 返回的 channel 中持续读取变化的资源，并转换为 DeltaFIFO 相应的调用
func (r *Reflector) watchHandler(w watch.Interface, resourceVersion *string, errc chan error, stopCh &lt;-chan struct{}) error {
    start := r.clock.Now()
    eventCount := 0
    defer w.Stop()
// 从这里开始无限循环从 channel 中读取资源的变化，也可以理解为资源的增量变化，同时还要监控各种信息
loop:
    for {
        select {
            // 退出信号
        case &lt;-stopCh:
            return errorStopRequested
            // 后台同步协程出错信息
        case err := &lt;-errc:
            return err
            // watch 函数返回的是一个channel，通过这个channel持续读取对象
        case event, ok := &lt;-w.ResultChan():
            // 如果不OK，说明channel关闭了，就要重新获取
            if !ok {
                break loop
            }
            if event.Type == watch.Error {
                return apierrs.FromObject(event.Object)
            }
            // 利用反射实例化对象获取对象类型，判断对象类型是不是我们期望的类型
            if e, a := r.expectedType, reflect.TypeOf(event.Object); e != nil &amp;&amp; e != a {
                utilruntime.HandleError(fmt.Errorf("%s: expected type %v, but watch event object had type %v", r.name, e, a))
                continue
            }
            // 和list操作相似，也要获取对象的版本，要更新缓存中的版本，下次 watch 就可以忽略这些资源了
            meta, err := meta.Accessor(event.Object)
            if err != nil {
                utilruntime.HandleError(fmt.Errorf("%s: unable to understand watch event %#v", r.name, event))
                continue
            }
            // 获取对象的版本
            newResourceVersion := meta.GetResourceVersion()
            // 根据事件的类型做不同的 DeltaFIFO 的操作
            switch event.Type {
                // 向 DeltaFIFO 添加一个 Add 的 Delta
            case watch.Added:
                err := r.store.Add(event.Object)
                if err != nil {
                    utilruntime.HandleError(fmt.Errorf("%s: unable to add watch event object (%#v) to store: %v", r.name, event.Object, err))
                }
                // 向 DeltaFIFO 添加一个 Update 的 Delta
            case watch.Modified:
                err := r.store.Update(event.Object)
                if err != nil {
                    utilruntime.HandleError(fmt.Errorf("%s: unable to update watch event object (%#v) to store: %v", r.name, event.Object, err))
                }
                // 删除对象，向 DeltaFIFO 添加一个删除的 Delta
            case watch.Deleted:
                err := r.store.Delete(event.Object)
                if err != nil {
                    utilruntime.HandleError(fmt.Errorf("%s: unable to delete watch event object (%#v) from store: %v", r.name, event.Object, err))
                }
            case watch.Bookmark:
                // Bookmark 意味着 watch 已经在这里同步，只需要更新 resourceVersion
            default:
                utilruntime.HandleError(fmt.Errorf("%s: unable to understand watch event %#v", r.name, event))
            }
            // 更新最新资源版本
            *resourceVersion = newResourceVersion
            // 设置最新同步的资源版本
            r.setLastSyncResourceVersion(newResourceVersion)
            eventCount++
        }
    }
    // watch返回时间非常短而且没有任何事件要处理，这个属于异常现象，因为我们watch是设置了超时的
    watchDuration := r.clock.Since(start)
    if watchDuration &lt; 1*time.Second &amp;&amp; eventCount == 0 {
        return fmt.Errorf("very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received", r.name)
    }
    klog.V(4).Infof("%s: Watch close - %v total %v items received", r.name, r.expectedType, eventCount)
    return nil
}</code></pre></p>
<p>然后是上面更新资源版本的函数实现：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/reflector.go
func (r *Reflector) setLastSyncResourceVersion(v string) {
    r.lastSyncResourceVersionMutex.Lock()
    defer r.lastSyncResourceVersionMutex.Unlock()

    // 设置已经获取到资源的最新版本
    r.lastSyncResourceVersion = v

    rv, err := strconv.Atoi(v)
    if err == nil {
        r.metrics.lastResourceVersion.Set(float64(rv))
    }
}

// 获取 resync 定时器，叫定时器比较好理解，叫chan很难和定时关联起来
func (r *Reflector) resyncChan() (&lt;-chan time.Time, func() bool) {
    // 如果 resyncPeriod 说明就不用定时同步，返回的是永久超时的定时器
    if r.resyncPeriod == 0 {
        return neverExitWatch, func() bool { return false }
    }
    // 构建一个定时器
    t := r.clock.NewTimer(r.resyncPeriod)
    return t.C(), t.Stop
}</code></pre></p>
<p>完整的 ListAndWatch 流程如下图所示：
<img alt="reflector listwatch" src="../../../assets/img/code/reflector-listwatch.png" /></p>
<p>上图中的 Resync 触发的 Sync 动作，其作用与 Replace 中的第三步相同，用于将 knowObject 中的对象与 DeltaFIFO 中同步。这种操作是有必要的。</p>
<p>最后，我们再次对 Reflector 做一下总结：</p>
<ul>
<li>Reflector 利用 apiserver 的 client 列举全量对象（版本为0以后的对象全部列举出来）</li>
<li>将全量对象采用 Replace() 接口同步到 DeltaFIFO 中，并且更新资源的版本号，这个版本号后续会用到</li>
<li>开启一个协程定时执行 resync，如果没有设置定时同步则不会执行，同步就是把全量对象以同步事件的方式通知出去</li>
<li>通过 apiserver 的 client 监控(watch)资源，监控的当前资源版本号以后的对象，因为之前的都已经全量获取到了</li>
<li>一旦有对象发生变化，那么就会根据变化的类型（新增、更新、删除）调用 DeltaFIFO 的相应接口，产生一个相应的对象 Delta，同时更新当前资源的版本</li>
</ul>
<h2 id="controller">Controller<a class="headerlink" href="#controller" title="Permanent link">&para;</a></h2>
<p>这里的 controller 和我们理解的 controller-manager 下面的各种控制器不一样，这里的 controller 定义在 <code>client-go/tools/cache/controller.go</code> 中，目的是用来把 <code>Reflector</code>、<code>DeltaFIFO</code> 组合起来形成一个相对固定的、标准的处理流程。Controller 的结构如下，其包含一个配置变量 config，在注释中可以看到 <code>Config.Queue</code> 就是 DeltaFIFO。Controller 定义了如何调度Reflector：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/controller.go
type Controller interface {
    Run(stopCh &lt;-chan struct{})  // 核心流程函数
    HasSynced() bool   // apiserver 中的对象是否已经同步到 Store 中
    LastSyncResourceVersion() string  // 最新的资源版本号
}</code></pre></p>
<p>从上面定义来看，HasSynced() 可以调用 DeltaFIOFO.HasSynced() 实现，LastSyncResourceVersion() 可以通过 Reflector 实现，因为 Controller 把多个模块整合起来实现一套逻辑，所以创建 Controller 需要提供一些配置：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/controller.go
// Config 包含一个 Controller 的所有设置
type Config struct {
    Queue  // 实际上就是 DeltaFIFO
    ListerWatcher  // 用于列举和监听对象的属性，用来构造 Reflector
    Process ProcessFunc  // 在调用 DeltaFIFO.Pop() 使用，弹出对象要如何处理
    ObjectType runtime.Object  // 对象类型
    FullResyncPeriod time.Duration  // 全量同步周期，在 Reflector 使用
    ShouldResync ShouldResyncFunc  // Reflector 在全量更新的时候会调用该函数询问
    RetryOnError bool  // 错误是否需要重试
}</code></pre></p>
<p>从上面两个类型的定义我们可以猜测：Controller 自己构造 Reflector 获取对象，Reflector 作为 DeltaFIFO 生产者持续监控 apiserver 的资源变化并推送到队列中。Controller 的 Run() 应该是队列的消费者，从队列中弹出对象并调用 Process() 处理。所以 Controller 相比于 Reflector因为队列的加持表现为每次有资源变化就会调用一次使用者定义的处理函数。</p>
<p>Controller 的框架比较简单它使用 wg.StartWithChannel 启动 Reflector.Run，相当于启动了一个 DeltaFIFO 的生产者(wg.StartWithChannel(stopCh, r.Run)表示可以将 <code>r.Run</code> 放在独立的协程运行，并可以使用 stopCh 来停止 r.Run)；使用 wait.Until 来启动一个消费者 (wait.Until(c.processLoop, time.Second, stopCh) 表示每秒会触发一次 c.processLoop，但如果 c.processLoop 在1秒之内没有结束，则运行 c.processLoop 继续运行，不会结束其运行状态):
<pre class="highlight"><code class="language-go">// client-go/tools/cache/controller.go
// controller 是一个通用的控制器框架。
type controller struct {
    config         Config  // controller的配置
    reflector      *Reflector  // 反射器指针
    reflectorMutex sync.RWMutex  // 反射器的锁
    clock          clock.Clock  // 时钟
}

// Run 开始处理 items，直到一个值被发送到 stopCh，多次调用 Run 是错误的，Run 函数是阻塞的，需要通过 go 调用
func (c *controller) Run(stopCh &lt;-chan struct{}) {
    defer utilruntime.HandleCrash()
    // 创建一个协程，如果收到系统退出的信号就关闭队列
    go func() {
        &lt;-stopCh
        c.config.Queue.Close()
    }()
    // 实例化 Reflector
    r := NewReflector(
        c.config.ListerWatcher,
        c.config.ObjectType,
        c.config.Queue,
        c.config.FullResyncPeriod,
    )
    r.ShouldResync = c.config.ShouldResync
    r.clock = c.clock
    // 记录 reflector
    c.reflectorMutex.Lock()
    c.reflector = r
    c.reflectorMutex.Unlock()
    // 被waitGroup管理的协程都退出后调用 Wait() 才会退出，否则就会被阻塞
    var wg wait.Group
    defer wg.Wait()

    // 放在独立的协程运行，调用 reflector 的 Run 函数，也就是去 ListAndWatch
    wg.StartWithChannel(stopCh, r.Run)
    // 周期性的调用 c.processLoop
    wait.Until(c.processLoop, time.Second, stopCh)
}</code></pre></p>
<p>processLoop 的框架也很简单，它运行了 DeltaFIFO.Pop 函数，用于消费 DeltaFIFO 中的对象，并在 DeltaFIFO.Pop 运行失败后可能重新处理该对象（AddIfNotPresent）:
<pre class="highlight"><code class="language-go">// client-go/tools/cache/controller.go
func (c *controller) processLoop() {
    for {
        // 从队列中弹出一个对象，然后处理它，这才是最主要的部分，这个c.config.Process是构造Controller的时候通过 Config 传进来的
        // 这个函数其实是ShareInformer传进来的，所以在分析 SharedInformer 的时候要重点分析的
        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))
        if err != nil {
            // 如果FIFO关闭了那就退出
            if err == FIFOClosedError {
                return
            }
            if c.config.RetryOnError {
                // 重新入队列的safe方法
                c.config.Queue.AddIfNotPresent(obj)
            }
        }
    }
}</code></pre></p>
<h2 id="shareinformer">ShareInformer<a class="headerlink" href="#shareinformer" title="Permanent link">&para;</a></h2>
<p>下图为 SharedInformer 的运行图。可以看出 SharedInformer 启动了 controller，reflector，并将其与 Indexer 结合起来。</p>
<blockquote>
<p>注：不同颜色表示不同的 channel，相同颜色表示在同一个 channel 中的处理</p>
</blockquote>
<p><img alt="sharedInformer" src="../../../assets/img/code/shared-informer.png" /></p>
<p>ShareInformer 的结构定义如下所示：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/shared_informer.go
type SharedInformer interface {
    // 添加资源事件处理器，相当于注册回调函数，当有资源变化就会通过回调通知使用者
    AddEventHandler(handler ResourceEventHandler)
    // 上面添加的是不需要周期同步的处理器，下面的接口添加的是需要周期同步的处理器
    AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)
    // 获取 Store 对象
    GetStore() Store
    // 获取 Controller 对象
    GetController() Controller
    // 核心逻辑实现的函数
    Run(stopCh &lt;-chan struct{})
    // 因为有 Store， 这个函数就是告知使用者 Store 里面是否已经同步了 apiserver 的资源，这个接口很有用
    // 当创建完 SharedInformer 后，通过 Reflector 从 apiserver 同步全量对象，然后再通过 DeltaFIFO 一个一个通知到 cache
    // 这个接口就是告知使用者，全量的对象是不是已经同步到了 cache，这样就可以从 cache 列举或者查询了
    HasSynced() bool
    // 最新同步资源的版本，通过 Controller 实现
    LastSyncResourceVersion() string
}

// 扩展 SharedInformer，从名字上看共享的是 Indexer，Indexer 也是一种 Store 的实现
type SharedIndexInformer interface {
    SharedInformer  // 继承 SharedInformer
    // 扩展 Indexer 的接口
    AddIndexers(indexers Indexers) error
    GetIndexer() Indexer
}

// client-go/tools/cache/controller.go
// SharedInformer 使用者如果需要处理资源的事件，那么就要自己实现相应的回调函数
type ResourceEventHandler interface {
    OnAdd(obj interface{})  // 添加对象
    OnUpdate(oldObj, newObj interface{})  // 更新对象
    OnDelete(obj interface{})  // 删除
}</code></pre></p>
<p>然后来看下 SharedInformer 的具体实现类的定义：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/shared_informer.go
type sharedIndexInformer struct {
    // Indexer 也是一种 Store，Controller 负责把 Reflector 和 FIFO 逻辑串联起来
    // 所以这两个变量就涵盖了 Reflector、DeletaFIFO 和 LocalStore（cache）
    indexer    Indexer
    controller Controller
    // sharedIndexInformer 把上面的 ResourceEventHandler 进行了一层封装，并统一由 sharedProcessor 管理
    processor             *sharedProcessor
    cacheMutationDetector CacheMutationDetector

    // 这两个变量是给 Reflector 使用的，Reflector 是在 Controller 中创建的
    listerWatcher ListerWatcher
    objectType    runtime.Object

    // 定期同步的周期，因为可能存在多个 ResourceEventHandler，就有可能存在多个同步周期，sharedIndexInformer 采用最小的周期
    // 这个周期值就存储在 resyncCheckPeriod 中，通过 AddEventHandler() 添加的处理器都采用 defaultEventHandlerResyncPeriod
    resyncCheckPeriod time.Duration
    defaultEventHandlerResyncPeriod time.Duration

    clock clock.Clock  // 时钟

    // 启动、停止标记，肯定有人会问为啥用两个变量，一个变量不就可以实现启动和停止了么？
    // 其实此处是三个状态，启动前，已启动和已停止，start表示了两个状态，而且为启动标记专门做了个锁
    // 说明启动前和启动后有互斥的资源操作

    started, stopped bool
    startedLock      sync.Mutex

    // 因为 DeltaFIFO 每次 Pop() 的时候需要传入一个函数用来处理 Deltas
    // 处理 Deltas 也就意味着要把消息通知给处理器，如果此时调用了 AddEventHandler()
    // 就会存在崩溃的问题，所以要有这个锁，阻塞 Deltas
    blockDeltas sync.Mutex
}</code></pre></p>
<h3 id="sharedprocessor">sharedProcessor<a class="headerlink" href="#sharedprocessor" title="Permanent link">&para;</a></h3>
<p>首先需要知道 Processor 的定义，这里定义的 Processor 就是处理事件的东西。什么事件，就是 SharedInformer 向外部通知的事件。我们还要了解一个新的类型，那就是 processorListener!</p>
<p>通过 SharedInformer.AddEventHandler() 添加的处理器最终就会封装成 processorListener，然后通过 sharedProcessor 管理起来，通过processorListener 的封装就可以达到所谓的有事处理，没事挂起。</p>
<p>processorListener 可以理解为两个核心功能，一个是 processor，一个是 listener，用一句话概括，有事做事没事挂起。先看看processorListener 的定义：
<pre class="highlight"><code class="language-go">// clien-go/tools/cache/shared_informer.go
type processorListener struct {
    // nextCh、addCh、handler、pendingNotifications 这四个变量实现了事件的输入、缓冲、处理，事件就是 apiserver 资源的变化
    nextCh chan interface{}
    addCh  chan interface{}

    handler ResourceEventHandler

    pendingNotifications buffer.RingGrowing

    // 下面四个变量就是跟定时同步相关的了，requestedResyncPeriod 是处理器设定的定时同步周期
    // resyncPeriod 是跟 sharedIndexInformer 对齐的同步时间，因为 sharedIndexInformer 管理了多个处理器
    // 最终所有的处理器都会对齐到一个周期上，nextResync 就是下一次同步的时间点
    requestedResyncPeriod time.Duration
    resyncPeriod time.Duration
    nextResync time.Time
    resyncLock sync.Mutex
}</code></pre></p>
<p>我们需要知道就是 processor 如何接收事件（此处事件就是 apiserver 的资源变化，也就是 DeltaFIFO 输出的 Deltas）？如何通知事件处理器？如何缓冲处理器？如何阻塞处理器进而形成 listener 的？一系列的问题我们需要沿着处理逻辑的流程逐一解释。第一个问题，事件是如何传入的:
<pre class="highlight"><code class="language-go">// client-go/tools/cache/shared_informer.go
// 对，通过 addCh 传入，这里面的 notification 就是我们所谓的事件
func (p *processorListener) add(notification interface{}) {
    p.addCh &lt;- notification
}</code></pre></p>
<p>因为 addCh 是无缓冲 channel，调用 add() 函数的人是事件分发器。意思就是从 DeltaFIFO 弹出的 Deltas 要逐一送到多个处理器，此时如果处理器没有及时处理会造成 addCh 把分发器阻塞，那别的处理器也就同样无法收到新的事件了。这一点，<code>processorListener</code> 利用一个后台协程处理这个问题：
<pre class="highlight"><code class="language-go">// client-go/tools/cache/shared_informer.go
func (p *processorListener) pop() {
    defer utilruntime.HandleCrash()
    defer close(p.nextCh) // Tell .run() to stop
    // 临时变量
    var nextCh chan&lt;- interface{}
    var notification interface{}
    // 进入死循环
    for {
        select {
            // 两种情况，nextCh 还没有初始化，这个语句就会被阻塞
            // nextCh 后面赋值为 p.nextCh，因为 p.nextCh 也是无缓冲的 channel，数据不发送成功就阻塞
        case nextCh &lt;- notification:
            // 如果发送成功了，那就从缓冲中再取一个事件出来
            var ok bool
            notification, ok = p.pendingNotifications.ReadOne()
            if !ok { // Nothing to pop
            // 如果没有事件，那就把 nextCh 再次设置为 nil，接下来对于 nextCh 操作还会被阻塞
                nextCh = nil // Disable this select case
            }
            // 从 p.addCh 读取一个事件出来
        case notificationToAdd, ok := &lt;-p.addCh:
        // p.addCh关闭了，只能退出了
            if !ok {
                return
            }
            // notification 为空说明当前还没有发送任何事件给处理器
            if notification == nil { // No notification to pop (and pendingNotifications is empty)
                // 把刚刚获取的事件通过 p.nextCh 发送给处理器
                notification = notificationToAdd
                nextCh = p.nextCh
            } else { // There is already a notification waiting to be dispatched
            // 上一个事件还没有发送成功，那就先放到缓存只能够
                p.pendingNotifications.WriteOne(notificationToAdd)
            }
        }
    }
}</code></pre></p>
<p>pop()函数实现的非常巧妙，利用一个协程就把接收、缓冲、发送全部解决了。它充分的利用了 golang 的 select 可以同时操作多个 channel 的特性，同时从 addChd 读取数据从 nextCh 发送数据，这两个 channel 任何一个完成都可以激活协程。接下来，我们看看从nextCh读取事件后是如何处理的：</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      



<!-- Application footer -->
<footer class="md-footer">

    <!-- Further information -->
    <div class="md-footer-meta md-typeset">
        <div class="md-footer-meta__inner md-grid">

            <!-- Copyright and theme information -->
            <div class="md-footer-copyright">
                
                <div class="md-footer-copyright__highlight">
                    Copyright &copy; 2020 Kubernetes技术栈
                </div>
                
                powered by
                <a href="https://www.k8stech.net" title="Kubernetes技术栈">www.k8stech.net</a>
            </div>

            <!-- Social links -->
            
            
            
        </div>
    </div>
</footer>


    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../assets/javascripts/workers/search.8397ff9e.min.js", "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.1e84347e.min.js"></script>
      
        <script src="../../../assets/js/hljs/highlight.pack.js"></script>
      
        <script src="../../../assets/js/prism.js"></script>
      
    
  </body>
</html>